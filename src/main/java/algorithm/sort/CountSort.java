package algorithm.sort;

/**
 * 计数排序（Counting Sort）
 * <p>
 * 计数排序不是基于比较的排序算法
 * <p>
 * 其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中
 * <p>
 * 作为一种线性时间复杂度的排序，计数排序要求: 输入的数据必须是有确定范围的整数
 * <p>
 * 算法步骤:
 * <p>
 * - 1.找出待排序的数组中最大和最小的元素；
 * - 2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
 * - 3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）;
 * - 4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
 * <p>
 * 评价:
 * <p>
 * - 计数排序是一个稳定的排序算法
 * <p>
 * - 当输入的元素是n个0到k之间的整数时: 时间复杂度是O(n+k),空间复杂度也是O(n+k),其排序速度快于任何比较排序算法
 * <p>
 * - 当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法
 *
 * @author zk
 */
public class CountSort extends BaseSort {

    public static void sort(int[] a) {
        // 一：求取最大值和最小值，计算中间数组的长度
        // 中间数组是用来记录原始数据中每个值出现的频率
        int max = a[0], min = a[0];
        for (int i : a) {
            if (i > max) {
                max = i;
            }
            if (i < min) {
                min = i;
            }
        }

        // 二：有了最大值和最小值能够确定中间数组的长度
        int[] aux = new int[max - min + 1];

        // 三.循环遍历旧数组计数排序: 统计原始数组值出现的频率到中间数组B中
        for (int i : a) {
            // 对应位置上+1
            aux[i - min] += 1;
        }

        // 四.遍历输出
        // 创建最终数组，就是返回的数组，和原始数组长度相等，但是排序完成的

        // 记录最终数组的下标
        int index = 0;
        // 先循环每一个元素, 在计数排序器的下标中
        for (int i = 0; i < aux.length; i++) {
            // 循环出现的次数
            // aux[i]:这个数出现的频率
            for (int j = 0; j < aux[i]; j++) {
                // 原来减少了min现在加上min，值就变成了原来的值
                a[index++] = i + min;
            }
        }
    }

}
